1章 基本事項の紹介と概要

データベース管理システムは様々な目的で利用される。例えば以下
・頻繁にアクセスされる一時的なホットデータ
・長期保存を前提としたコールドストレージ
またいろいろな分類で分けることができるのでまずは定義から。

DBMSアーキテクチャ
データベース管理システムの設計に共通する青写真はない。
すべてのデータベースの構成が少しずつ異なっていてコンポーネントの境界を
理解して定義することは困難。
データベース管理システムではクライアント/サーバモデルが使用される。
クライアントのリクエストは転送サブシステムを介して受信される。
リクエストはクエリの形式で送信されてくる。これらは多くの場合、いずれかのクエリ言語で表される。
転送サブシステムはデータベースクラスタ内で他のノードとの通信を行う機能も果たす。
転送サブシステムはクエリを受け取るとそのクエリをクエリプロセッサに渡す。
クエリプロセッサではクエリの解析や解釈、検証を行いアクセス制御チェックを行う。
解析されたクエリはクエリオプティマイザに渡される。
クエリオプティマイザはクエリの実行不可能な部分と条項な部分を排除し、クエリを実行するための
効率的な方法を探索する。その場合の基準はインデックスのカーディナリティや交点のおおよそのサイズなどの
内部的な統計情報およびクラスタ内でデータが格納されているノードと
その転送に関連付けられるコストといったデータの配置。
オプティマイザはクエリの解決に必要なリレーショナルな操作とインデックスオーダリング、カーディナリティ見積、
アクセスメソッドの選択といった最適化の両方を処理する。
クエリは通常、実行計画またはクエリ計画の形式で表される。
→完全な結果を得るために実行する必要がある一連の操作。同じクエリであっても効率が異なる様々な実行計画を使用して
目的を達成することが可能なので使用可能な計画の中から最善の計画を選択する。
実行計画は実行エンジンによって処理される。
このエンジンはローカル操作とリモート操作の実行結果を収集する。
リモート実行→クラスタ内の他のノードで行われるデータの書き込み、読み込み、レプリケーションが含まれる。
ローカルクエリ→クライアントまたは他のノードから直接受け取りストレージエンジンによって実行される。
ストレージエンジンはそれぞれの機能に特化した複数のコンポーネントが実行される。
・トランザクションマネージャー
　トランザクションのスケジュールを管理しデータベースが論理的に一貫性を失った状態にならないようにする
・ロックマネージャー
　トランザクションを実行するためにデータベースオブジェクトをロックして並行処理によって物理的なデータの整合性が
　侵されないようにする
・アクセスメソッド
　ディスク上のデータへのアクセスとそれらの構成を管理する
・バッファマネージャー
　データページをメモリにキャッシュする。
・リカバリマネージャー
　操作ログを管理して障害が発生した場合にシステムの状態を復旧する。
トランザクションマネージャとロックマネージャーは連動して同時実行制御を行う。
これらのマネージャは論理的及び物理的なデータの整合性を保証すると同時に並行処理が可能な限り効率的に実行されるようにする。

メモリベースのDBMSとディスクベースのDBMS
データベースシステムはデータをメモリとディスク上に格納する。
インメモリデータベース管理システムはデータを主にメモリに保持しディスクをリカバリとログ管理に使用する。
ディスクベースはデータの大半をディスク上に格納しメモリはディスクの内容をキャッシュしたり一時的なストレージとして使う。
違いは利用する主要なストレージメディアだけでなくデータの構造、編成、最適化に使用される技術に違いがある。
データベースで主なデータストアとしてメモリを使用するのはパフォーマンスや、比較的低いアクセスコスト、アクセスのより細かい単位などの理由から。
またメインメモリ向けのプログラム作成はディスク向けに比べて単純。
OSによってメモリ管理が抽象化されるので任意のサイズのメモリをまとめて割り当てたり解法したりという観点から考え始めることができる。
ディスクの場合にはデータの参照、シリアライズのフォーマット、解法済み領域、フラグメンテーションを手動で管理することになる。
インメモリデータベースの制約はRAMの揮発性。
メモリベースのストアの永続性
メインメモリデータベースシステムではバックアップをディスク上に格納して永続性を実現し、揮発性データの紛失を防止します。
データベースの中にはデータをメモリ内にのみ配置して永続性の保証を全く行わないものもある。
操作が完了したと判断できるようにするにはその前に結果がシーケンシャルなログファイルに書き込まれる必要がある。
起動中、またはクラッシュ後における完全なログの内容のリプレイを避けるために
インメモリのデータストアではバックアップコピーが取得される。バックアップコピーはソートされたディスクベースの構造として保持される。
この構造に対する変更はクライアントのリクエストから分離されて多くの場合は非同期でありI/Oの回数を削減するためにバッチ処理で適用される。
リカバリの場合はバックアップとログから復元できる。
ログレコードのバッチ処理が終了すると特定の時点のデータベースのスナップショットがバックアップによって保持され、
この時点までのログ内容は破棄できるようになる。このプロセスをチェックポイント処理と呼ぶ
ディスクベースのデータベースではディスクアクセスに最適化された特殊なストレージ構造を使用する。
メモリ上ではポインタを比較的高速にたどることができ、ランダムなメモリアクセスの方がランダムなディスクアクセスよりも早い。
ディスクベースのストレージ構造は多くの場合は幅が広くて高さの低いツリー構造になる。
メモリベースの実装は比較的多くのデータ構造から選べる。

列指向DBMSと行指向DBMS
大半のデータベースシステムは一連のデータレコードを格納する。
これらはテーブルの列と行で構成される。列と行が交差する部分がフィールド。
同じ列に属するフィールドは普通同じデータ型。
データベースを分類する1つの方法はディスク上でデータがどのように格納されるか。
行指向はMySQLなど。列指向はMonentDB。
行指向のデータレイアウト
行指向データベースの管理システムではデータをレコードまたは行に格納する。
そのレイアウトは表形式に似てる。
このアプローチは複数のフィールドがキーによって一意に識別される場合に有効。
行指向ストアは行単位でデータにアクセスすることが必要なケースにおいてもっとも有用。
行全体をまとめて格納することで空間的局所性が改善される。
列指向のデータレイアウト
列指向データベース管理システムではデータを行形式ではなく垂直指向に保持する。
例えば過去の株式市場価格を格納する場合、価格相場はまとめて格納される。
異なる列の値をそれぞれ別のファイルに格納することによって列ごとに効率的なクエリが可能になる。
列指向ストアはトレンドの把握や平均値の計算のような集計処理を行う分析的なワークロードに適している。
相違点と最適化
行指向と列指向の違いは格納される方法だけではない。
同じ列の複数の値を1回の処理で読み取ることはキャッシュの利用と計算効率を大幅に改善する。
同じデータ型の値をまとめて格納すると圧縮率が向上する。
どちらを使用するかはアクセスパターンを理解する必要がある。
読み取りデータがレコード単位で読む場合は行指向が良く、列のサブセットで集計を計算するためには列指向が良い。
ワイドカラムストア
列指向データベースはワイドカラムストアと混同しないように注意。
ワイドカラムストアではデータが多次元マップとしてあらわされる。

データファイルとインデックスファイル
データベースシステムの主要な目的はデータを格納すること、データへの迅速なアクセスを可能にすること。
データベースシステムはデータの格納にファイルを利用するが、レコードを検索する場合にディレクトリと
ファイルで構成されるファイルシステムの階層に依存せずそれぞれの実装固有のフォーマットを使用してファイルを構成する。
特殊なファイル構成を使用する主な理由は以下
・ストレージの効率性
・アクセスの効率性
・更新の効率性
データベースシステムは複数のフィールドで構成されるデータレコードをテーブルに格納する。
各テーブルごとに個別のファイルが対応する。
テーブル内の各レコードは検索キーを利用して検索できる。
検索するためにインデックスを使用する。
インデックスはレコードを識別するフィールドのサブセットを使用して構築される。
データベースシステムはデータファイルとインデックスファイルが分けられている。
データファイルにはデータレコードを格納。
インデックスファイルにはレコードメタデータを格納。
ファイルはページに分割。
新規レコードの挿入と既存のレコードの更新はキーとバリューのペアで表される。
最新のストレージシステムではデータをページから明示的に削除しない。
その代わりに削除マーカーを使用する。
→キーやタイムスタンプなどの削除メタデータが含まれる。
更新や削除マーカーによって無効にされたレコードが占めているスペースはガベージコレクションの際に回収される。
データファイル
データファイルはインデックス構成表、ヒープ構成表、ハッシュ構成表として実装できる。
ヒープファイル内のレコードは特定の順序に従う必要なく書き込み順に配置される。
この方法は新規ページが追加されたときにも余分な作業やファイルの再構成の必要がない。
ヒープファイルには別途インデックス構造が必要。
インデックスによりデータレコードが格納されている場所が指し示され検索できるようになうｒ。
ハッシュファイルではレコードはバケットに格納される。キーのハッシュ値によってレコードが
どのバケットに属するかが決定される。
バケット内のレコードは追加された順に格納されたり検索速度を改善するためにキーに基づいてソートされることもある。
インデックス構成表ではデータレコードがインデックス自体に格納される。
データレコードをインデックスに格納することでディスクのシーク回数を少なくとも1回は削減できる。
レコードがあるデータファイルに格納されているとき、インデックスファイルはデータエントリを保持する。
データエントリはレコードを一意に識別しそのファイル内からそれらのレコードを検索するための情報を含む。
インデックスファイル
インデックス＝効率的に検索できるようにディスク上のデータレコードをまとめたもの。
インデックスファイルはデータファイル内の場所にキーをマッピングする特殊な構造をもっている。
その場所はキーや主キーによって識別される場所。
プライマリファイル上のインデックスはプライマリインデックスと呼ばれる。その他はすべてセカンダリ。
データレコードの順序が検索キー順に従っている場合、このインデックスはクラスタ化されているという。
クラスタ化されている場合、データレコードたちは通常同じファイルまたはクラスタ化ファイルに格納され
その中でキーの順序が維持される。データが別個のファイルに格納されその順序がキー順に従っていない場合は非クラスタ化。
プライマリキーを指定できるが、指定されない場合は暗黙的なプライマリキーが設定できる。
間接参照としてのプライマリインデックス
データレコードの参照はファイルオフセットを使用するかプライマリキーインデックスを使うかで意見が分かれている。
どちらのアプローチも賛否両論がある。

バッファリングとイミュータビリティおよびオーダリング
ストレージエンジンはいずれかのデータ構造に基づいている。ただしストレージエンジンで
データ構造の基盤の上に追加されるキャッシュ機能、リカバリ、トランザクション性などの意味が
これらのデータ構造によって説明されるわけではない。
ストレージ構造には共通した変動要素が3つある
・バッファリング
→ストレージ構造がデータをディスク上に格納する前に一定量のデータをメモリ内に収集するかを定義。
・イミュータビリティ
→ストレージ構造がファイルの一部を読み取り、それらを更新し更新の結果をファイルの同じ場所へ書き込むかを定義
・オーダーリング
→ディスク上のページにデータレコードをキーの順序で格納するかを定義